From 505eaaf3490c21de00e636d012f513f4334ed5c3 Mon Sep 17 00:00:00 2001
From: Michael Stapelberg <michael@stapelberg.de>
Date: Fri, 01 Jan 2010 21:40:50 +0100
Subject: Bugfix: Containers could lose their snap state (Thanks Atsutane)

When being on a different workspace than the one where the snapped
container is, the function to cleanup cols/rows would clean up too
much.
---
diff --git a/include/table.h b/include/table.h
index 1856147..6236bef 100644
--- i3-3.d-bf1.orig/include/table.h
+++ i3-3.d-bf1/include/table.h
@@ -48,7 +48,7 @@ void expand_table_cols_at_head(Workspace *workspace);
  * Performs simple bounds checking for the given column/row
  *
  */
-bool cell_exists(int col, int row);
+bool cell_exists(Workspace *ws, int col, int row);
 
 /**
  * Shrinks the table by "compacting" it, that is, removing completely empty
diff --git a/src/click.c b/src/click.c
index efb26ad..dbbc433 100644
--- i3-3.d-bf1.orig/src/click.c
+++ i3-3.d-bf1/src/click.c
@@ -211,7 +211,7 @@ static bool floating_mod_on_tiled_client(xcb_connection_t *conn, Client *client,
                 first = con->col + (con->colspan - 1);
                 LOG("column %d\n", first);
 
-                if (!cell_exists(first, con->row) ||
+                if (!cell_exists(ws, first, con->row) ||
                     (first == (ws->cols-1)))
                         return false;
 
@@ -239,7 +239,7 @@ static bool floating_mod_on_tiled_client(xcb_connection_t *conn, Client *client,
                    to_bottom < to_top) {
                 /* …bottom border */
                 first = con->row + (con->rowspan - 1);
-                if (!cell_exists(con->col, first) ||
+                if (!cell_exists(ws, con->col, first) ||
                     (first == (ws->rows-1)))
                         return false;
 
@@ -376,7 +376,7 @@ int handle_button_press(void *ignored, xcb_connection_t *conn, xcb_button_press_
         } else if (event->event_y >= (client->rect.height - 2)) {
                 /* …bottom border */
                 first = con->row + (con->rowspan - 1);
-                if (!cell_exists(con->col, first) ||
+                if (!cell_exists(ws, con->col, first) ||
                     (first == (ws->rows-1)))
                         return 1;
 
@@ -394,7 +394,7 @@ int handle_button_press(void *ignored, xcb_connection_t *conn, xcb_button_press_
                 first = con->col + (con->colspan - 1);
                 LOG("column %d\n", first);
 
-                if (!cell_exists(first, con->row) ||
+                if (!cell_exists(ws, first, con->row) ||
                     (first == (ws->cols-1)))
                         return 1;
 
diff --git a/src/commands.c b/src/commands.c
index 4ef03d9..d60de2c 100644
--- i3-3.d-bf1.orig/src/commands.c
+++ i3-3.d-bf1/src/commands.c
@@ -143,9 +143,9 @@ static void focus_thing(xcb_connection_t *conn, direction_t direction, thing_t t
                         if (focus_window_in_container(conn, container, direction))
                                 return;
 
-                if (direction == D_DOWN && cell_exists(current_col, current_row+1))
+                if (direction == D_DOWN && cell_exists(t_ws, current_col, current_row+1))
                         new_row = current_row + t_ws->table[current_col][current_row]->rowspan;
-                else if (direction == D_UP && cell_exists(current_col, current_row-1)) {
+                else if (direction == D_UP && cell_exists(c_ws, current_col, current_row-1)) {
                         /* Set new_row as a sane default, but it may get overwritten in a second */
                         new_row--;
 
@@ -186,9 +186,9 @@ static void focus_thing(xcb_connection_t *conn, direction_t direction, thing_t t
                         LOG("Fixed it to new col %d\n", new_col);
                 }
         } else if (direction == D_LEFT || direction == D_RIGHT) {
-                if (direction == D_RIGHT && cell_exists(current_col+1, current_row))
+                if (direction == D_RIGHT && cell_exists(t_ws, current_col+1, current_row))
                         new_col = current_col + t_ws->table[current_col][current_row]->colspan;
-                else if (direction == D_LEFT && cell_exists(current_col-1, current_row)) {
+                else if (direction == D_LEFT && cell_exists(t_ws, current_col-1, current_row)) {
                         /* Set new_col as a sane default, but it may get overwritten in a second */
                         new_col--;
 
@@ -451,7 +451,7 @@ static void snap_current_container(xcb_connection_t *conn, direction_t direction
         switch (direction) {
                 case D_LEFT:
                         /* Snap to the left is actually a move to the left and then a snap right */
-                        if (!cell_exists(container->col - 1, container->row) ||
+                        if (!cell_exists(container->workspace, container->col - 1, container->row) ||
                             CUR_TABLE[container->col-1][container->row]->currently_focused != NULL) {
                                 LOG("cannot snap to left - the cell is already used\n");
                                 return;
@@ -464,7 +464,7 @@ static void snap_current_container(xcb_connection_t *conn, direction_t direction
                         /* Check if the cell is used */
                         int new_col = container->col + container->colspan;
                         for (int i = 0; i < container->rowspan; i++)
-                                if (!cell_exists(new_col, container->row + i) ||
+                                if (!cell_exists(container->workspace, new_col, container->row + i) ||
                                     CUR_TABLE[new_col][container->row + i]->currently_focused != NULL) {
                                         LOG("cannot snap to right - the cell is already used\n");
                                         return;
@@ -484,7 +484,7 @@ static void snap_current_container(xcb_connection_t *conn, direction_t direction
                         break;
                 }
                 case D_UP:
-                        if (!cell_exists(container->col, container->row - 1) ||
+                        if (!cell_exists(container->workspace, container->col, container->row - 1) ||
                             CUR_TABLE[container->col][container->row-1]->currently_focused != NULL) {
                                 LOG("cannot snap to top - the cell is already used\n");
                                 return;
@@ -497,7 +497,7 @@ static void snap_current_container(xcb_connection_t *conn, direction_t direction
                         LOG("snapping down\n");
                         int new_row = container->row + container->rowspan;
                         for (int i = 0; i < container->colspan; i++)
-                                if (!cell_exists(container->col + i, new_row) ||
+                                if (!cell_exists(container->workspace, container->col + i, new_row) ||
                                     CUR_TABLE[container->col + i][new_row]->currently_focused != NULL) {
                                         LOG("cannot snap down - the cell is already used\n");
                                         return;
@@ -823,7 +823,7 @@ static void parse_resize_command(xcb_connection_t *conn, Client *last_focused, c
                 first = con->col + (con->colspan - 1);
                 LOG("column %d\n", first);
 
-                if (!cell_exists(first, con->row) ||
+                if (!cell_exists(ws, first, con->row) ||
                     (first == (ws->cols-1)))
                         return;
 
@@ -838,7 +838,7 @@ static void parse_resize_command(xcb_connection_t *conn, Client *last_focused, c
                 command += strlen("top");
         } else if (STARTS_WITH(command, "bottom")) {
                 first = con->row + (con->rowspan - 1);
-                if (!cell_exists(con->col, first) ||
+                if (!cell_exists(ws, con->col, first) ||
                     (first == (ws->rows-1)))
                         return;
 
diff --git a/src/table.c b/src/table.c
index eebe8de..4330ca1 100644
--- i3-3.d-bf1.orig/src/table.c
+++ i3-3.d-bf1/src/table.c
@@ -241,9 +241,9 @@ static void shrink_table_rows(Workspace *workspace) {
  * Performs simple bounds checking for the given column/row
  *
  */
-bool cell_exists(int col, int row) {
-        return (col >= 0 && col < c_ws->cols) &&
-               (row >= 0 && row < c_ws->rows);
+bool cell_exists(Workspace *ws, int col, int row) {
+        return (col >= 0 && col < ws->cols) &&
+               (row >= 0 && row < ws->rows);
 }
 
 static void free_container(xcb_connection_t *conn, Workspace *workspace, int col, int row) {
@@ -388,7 +388,7 @@ void fix_colrowspan(xcb_connection_t *conn, Workspace *workspace) {
                 if (con->colspan > 1) {
                         LOG("gots one with colspan %d (at %d c, %d r)\n", con->colspan, cols, rows);
                         while (con->colspan > 1 &&
-                               (!cell_exists(cols + (con->colspan-1), rows) ||
+                               (!cell_exists(workspace, cols + (con->colspan-1), rows) &&
                                 workspace->table[cols + (con->colspan - 1)][rows]->currently_focused != NULL))
                                 con->colspan--;
                         LOG("fixed it to %d\n", con->colspan);
@@ -396,7 +396,7 @@ void fix_colrowspan(xcb_connection_t *conn, Workspace *workspace) {
                 if (con->rowspan > 1) {
                         LOG("gots one with rowspan %d (at %d c, %d r)\n", con->rowspan, cols, rows);
                         while (con->rowspan > 1 &&
-                               (!cell_exists(cols, rows + (con->rowspan - 1)) ||
+                               (!cell_exists(workspace, cols, rows + (con->rowspan - 1)) &&
                                 workspace->table[cols][rows + (con->rowspan - 1)]->currently_focused != NULL))
                                 con->rowspan--;
                         LOG("fixed it to %d\n", con->rowspan);
--
cgit v0.8.3
